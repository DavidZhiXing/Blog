- 任务DSL
- 任务生成
- 任务启动
- 任务运行
- 任务结束

### 任务DSL
负责构造任务；
任务的输入为json格式；
TaskFactory.cs
``` c#
        public static ITask Create(JObject jo)
        {
            string taskTypeName = jo[TaskPropertyTag.TaskType].ToString();
            TaskType taskType = (TaskType)Enum.Parse(typeof(TaskType), taskTypeName);
            IEnumerable<int> pathNos = Enumerable.Empty<int>();
            IEnumerable<int> ctrlPathNos = Enumerable.Empty<int>();
            if (jo.ContainsKey(TaskPropertyTag.Path))
            {
                pathNos = (jo[TaskPropertyTag.Path] as JArray).Select(item => (int)item).ToArray();
            }
            if (jo.ContainsKey(TaskPropertyTag.CtrlPath))
            {
                ctrlPathNos = (jo[TaskPropertyTag.CtrlPath] as JArray).Select(item => (int)item).ToArray();
            }
            UpdateCtrlPath(pathNos, ctrlPathNos);

            Dictionary<string, string> information = new Dictionary<string, string>();
            foreach (var item in jo.Properties())
            {
                if (item.Name != TaskPropertyTag.TaskType && item.Name != TaskPropertyTag.Path)
                {
                    information.Add(item.Name, item.Value.ToString());
                }
            }
            return Create(TaskBase.AnonymousTaskId, taskType, pathNos, information);
        }
```
根据通讯协议创建任务；
``` c#
        public static ITask Create(long taskId, TaskType taskType, IEnumerable<int> paths, IDictionary<string, string> specialInformation)
        {
            Dictionary<string, string> si = new Dictionary<string, string>();
            if (taskId != 0)
            {
                si.Add("TaskId", taskId.ToString());
            }
            foreach (var item in specialInformation)
            {
                si.Add(item.Key, item.Value);
            }
            if (paths.Any())
            {
                si.Add("Path", $"[{string.Join(",", paths)}]");
            }
            if (!paths.Any() && specialInformation.ContainsKey("PathNos"))
            {
                string pathNos = specialInformation["PathNos"];
                paths = pathNos.TrimEnd().Split(',').Select(item => int.Parse(item)).ToArray();
            }
            AddParamsFromParkConfig(specialInformation, si);

            TaskCreater taskCreater = null;
            if (taskType == TaskType.TaskClassNameSpecific)
            {
                string taskClassName;
                if (specialInformation.TryGetValue(TaskPropertyTag.TaskClassName, out taskClassName))
                {
                    TaskCreatersByTaskClassName.TryGetValue(taskClassName, out taskCreater);
                }
            }
            else
            {
                TaskCreatersByTaskType.TryGetValue(taskType, out taskCreater);
            }
            if (taskCreater != null)
            {
                Path path = null;
                if (taskCreater.PathIsRequired || paths.Any())
                {
                    if (PathManager.Manager.Check(paths))
                    {
                        bool result;
                        string information=string.Empty;
                        AGV.Breakdowns.Tester.PathConnectivityForceTester.RuntimeTest(paths, out result, out information);
                        if (result)
                        {
                            string message = Multilingual.MultilingualHelper.CreateInstance().GetLanguageValueByKey("PathConnectivityOverLimit");
                            throw new ArgumentOutOfRangeException($"{message}{information}");
                        }
                        path = PathManager.Manager.Build(paths);
                    }
                    else
                    {
                        throw new Exception("路径信息错误");
                    }

                 }
                var log = log4net.LogManager.GetLogger("AGV");
                if (log.IsDebugEnabled)
                {
                    log.Debug(si);
                }
                try
                {
                    return taskCreater.Create(taskId, path, si);
                }
                catch (Exception e)
                {
                    LogCreateException(e);
                    System.Reflection.TargetInvocationException tie = e as System.Reflection.TargetInvocationException;
                    if (tie != null && tie.InnerException != null)
                    {
                        throw e.InnerException;
                    }
                    else
                    {
                        throw e;
                    }
                }
            }
            throw new NotSupportedException("任务类型不支持");
        }
```
### 任务生成
- 根据DSL的结果，得到ClassName;
- 使用反射根据ClassName得到任务的创建器（工厂）
    
所以通过这里我们查看TaskBase的继承类，那么就可以得到我们能够创建什么类型的任务了