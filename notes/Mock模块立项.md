**目的（优点）：**

- (1)提高 A 的测试覆盖率。A 依赖 B，本质上依赖的是 B 的返回结果，也就是说 B 的返回结果会影响 A 的行为。通过 mock B 我们可以构造各种正常和异常的来自 B 的返回结果，从而更充分测试 A 的行为。

- (2)避免 B 的因素从而对 A 产生影响。依赖真实的 B 去测试 A 可能有很多问题：B 的开发没有完成时无法测试 A;B 有阻塞性bug 时无法测试 A;B 的依赖 C 有阻塞性 bug 时无法测试 A;

- (3)提高 A 的测试效率。B 的真实行为可能很慢，而 B 的模拟行为是非常快的，因此可以加快 A 的测试执行速度。

  ![](C:\Users\wow_o\Downloads\662605cdbbb518af6ef4658964d6eb5c.png-wh_600x-s_2549539200.png)

**现状：**

目前Agv只有简单的Mock, 不够完善

**分类：**

- (1)方法级别 mock：mock 的对象是一个函数调用，例如获取系统环境变量。

- (2)类级别 mock：mock 的对象是一个类，例如一个 HTTP server。

- (3)接口级别 mock：mock 的对象是一个 API 接口。

- (4)服务级别 mock：mock 的对象是整个服务。比如前端工程师自测试时，可以讲后端整个服务都 mock 掉，这其实等同于将后端的所有接口都 mock。

  ![](C:\Users\wow_o\Downloads\7d0b4d787d765cfa5d605d7d83b26e9f.png-wh_600x-s_4187113598.png)

**Mock的注入方式：**

改造被测服务的 API 请求方法，即在 API 请求方法中加入 mock 处理逻辑。当满足某些条件时执行 mock 分支，不满足时执行真实分支。

![](C:\Users\wow_o\Downloads\f6a135c801b3985321b20d6c3bcc260d.png-wh_600x-s_2081590074.png)

目前需要改造和完善的模块：

- Device（设备）
- Posture Analyzer (定位)
- Motion （运动控制）
- Path （路径）
- Fork Perception (感知)
- 中控（优先级低）

**使用：**

对于测试用例来说，我们不仅关心 mock 是否返回了期望的结果，还需要关心 SUT 是否以期望的方式调用了 mock 对象。

如果 SUT 没有以期望的方式调用，比如：没有传参或者参数不对，那么 SUT 就存在问题。

mock 需要详细记录来自SUT 的调用信息，并提供给用例来校验。

![](C:\Users\wow_o\Downloads\60c44f5de0f18b4a014ed15cac809426.png-wh_600x-s_1613471210.png)

**缺点：**

- (1)mock 可能导致问题遗漏。mock 的模拟行为与真实行为可能存在 GAP，导致基于 mock 的测试虽然通过了，但是基于真实对象的测试却失败了，这意味着问题被遗漏了。mock 很难模拟所有的真实情况。
- (2)mock 带来较高的维护成本。基于 mock 的测试用例结构比较复杂，实现和维护都不容易，后期被测代码有变动时需要适配 mock 代码。

